Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COLON

Grammar

Rule 0     S' -> program
Rule 1     program -> variables methods MAIN LBRACE severalstatutes RBRACE
Rule 2     statutes -> conditional
Rule 3     statutes -> editvariables
Rule 4     statutes -> cyclical
Rule 5     statutes -> calling
Rule 6     statutes -> readwrite
Rule 7     editvariables -> ID ASSIGN arithexp SEMICOLON
Rule 8     editvariables -> ID dimensions ASSIGN arithexp SEMICOLON
Rule 9     editvariables -> selectid PLUSPLUS SEMICOLON
Rule 10    editvariables -> selectid MINUSMINUS SEMICOLON
Rule 11    selectid -> ID
Rule 12    selectid -> ID dimensions
Rule 13    conditional -> IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE
Rule 14    conditional -> IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE ELSE LBRACE severalstatutes RBRACE
Rule 15    severalstatutes -> statutes severalstatutes
Rule 16    severalstatutes -> statutes
Rule 17    severalstatutes -> empty
Rule 18    cyclical -> DO LBRACE severalstatutes RBRACE WHILE LPAREN logicexp RPAREN
Rule 19    cyclical -> WHILE LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE
Rule 20    cyclical -> FOR LPAREN ID ASSIGN CONST SEMICOLON logicexp SEMICOLON arithexp RPAREN LBRACE severalstatutes RBRACE
Rule 21    variables -> type ID SEMICOLON variables
Rule 22    variables -> type ID dimensions SEMICOLON
Rule 23    variables -> empty
Rule 24    dimensions -> LBRACKET idconst RBRACKET dimensions
Rule 25    dimensions -> LBRACKET idconst RBRACKET
Rule 26    type -> INT
Rule 27    type -> DOUBLE
Rule 28    methods -> METHOD ID LPAREN RPAREN LBRACE severalstatutes RBRACE methods
Rule 29    methods -> empty
Rule 30    calling -> CALL ID LPAREN RPAREN SEMICOLON
Rule 31    readwrite -> READ LPAREN idreadingloop RPAREN SEMICOLON
Rule 32    readwrite -> WRITE LPAREN writecontent RPAREN SEMICOLON
Rule 33    idreadingloop -> ID COMA idreadingloop
Rule 34    idreadingloop -> ID
Rule 35    writecontent -> arithfunction
Rule 36    writecontent -> logicfunction
Rule 37    arithexp -> arithterm
Rule 38    arithexp -> arithterm PLUS arithexp
Rule 39    arithexp -> arithterm MINUS arithexp
Rule 40    arithterm -> arithfunction
Rule 41    arithterm -> arithfunction TIMES arithterm
Rule 42    arithterm -> arithfunction DIVISION arithterm
Rule 43    arithfunction -> idconst
Rule 44    arithfunction -> ID PLUSPLUS
Rule 45    arithfunction -> ID MINUSMINUS
Rule 46    arithfunction -> LPAREN arithexp RPAREN
Rule 47    logicexp -> logicterm
Rule 48    logicexp -> logicterm OR logicexp
Rule 49    logicterm -> logicfunction
Rule 50    logicterm -> logicfunction AND logicterm
Rule 51    logicfunction -> idconst LESSTHAN idconst
Rule 52    logicfunction -> idconst GREATERTHAN idconst
Rule 53    logicfunction -> idconst EQUALS idconst
Rule 54    logicfunction -> LPAREN logicexp RPAREN
Rule 55    idconst -> ID
Rule 56    idconst -> CONST
Rule 57    empty -> <empty>

Terminals, with rules where they appear

AND                  : 50
ASSIGN               : 7 8 20
CALL                 : 30
COLON                : 
COMA                 : 33
CONST                : 20 56
DIVISION             : 42
DO                   : 18
DOUBLE               : 27
ELSE                 : 14
EQUALS               : 53
FOR                  : 20
GREATERTHAN          : 52
ID                   : 7 8 11 12 20 21 22 28 30 33 34 44 45 55
IF                   : 13 14
INT                  : 26
LBRACE               : 1 13 14 14 18 19 20 28
LBRACKET             : 24 25
LESSTHAN             : 51
LPAREN               : 13 14 18 19 20 28 30 31 32 46 54
MAIN                 : 1
METHOD               : 28
MINUS                : 39
MINUSMINUS           : 10 45
OR                   : 48
PLUS                 : 38
PLUSPLUS             : 9 44
RBRACE               : 1 13 14 14 18 19 20 28
RBRACKET             : 24 25
READ                 : 31
RPAREN               : 13 14 18 19 20 28 30 31 32 46 54
SEMICOLON            : 7 8 9 10 20 20 21 22 30 31 32
TIMES                : 41
WHILE                : 18 19
WRITE                : 32
error                : 

Nonterminals, with rules where they appear

arithexp             : 7 8 20 38 39 46
arithfunction        : 35 40 41 42
arithterm            : 37 38 39 41 42
calling              : 5
conditional          : 2
cyclical             : 4
dimensions           : 8 12 22 24
editvariables        : 3
empty                : 17 23 29
idconst              : 24 25 43 51 51 52 52 53 53
idreadingloop        : 31 33
logicexp             : 13 14 18 19 20 48 54
logicfunction        : 36 49 50
logicterm            : 47 48 50
methods              : 1 28
program              : 0
readwrite            : 6
selectid             : 9 10
severalstatutes      : 1 13 14 14 15 18 19 20 28
statutes             : 15 16
type                 : 21 22
variables            : 1 21
writecontent         : 32

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . variables methods MAIN LBRACE severalstatutes RBRACE
    (21) variables -> . type ID SEMICOLON variables
    (22) variables -> . type ID dimensions SEMICOLON
    (23) variables -> . empty
    (26) type -> . INT
    (27) type -> . DOUBLE
    (57) empty -> .

    INT             shift and go to state 5
    DOUBLE          shift and go to state 6
    METHOD          reduce using rule 57 (empty -> .)
    MAIN            reduce using rule 57 (empty -> .)

    program                        shift and go to state 1
    variables                      shift and go to state 2
    type                           shift and go to state 3
    empty                          shift and go to state 4

state 1

    (0) S' -> program .



state 2

    (1) program -> variables . methods MAIN LBRACE severalstatutes RBRACE
    (28) methods -> . METHOD ID LPAREN RPAREN LBRACE severalstatutes RBRACE methods
    (29) methods -> . empty
    (57) empty -> .

    METHOD          shift and go to state 8
    MAIN            reduce using rule 57 (empty -> .)

    methods                        shift and go to state 7
    empty                          shift and go to state 9

state 3

    (21) variables -> type . ID SEMICOLON variables
    (22) variables -> type . ID dimensions SEMICOLON

    ID              shift and go to state 10


state 4

    (23) variables -> empty .

    METHOD          reduce using rule 23 (variables -> empty .)
    MAIN            reduce using rule 23 (variables -> empty .)


state 5

    (26) type -> INT .

    ID              reduce using rule 26 (type -> INT .)


state 6

    (27) type -> DOUBLE .

    ID              reduce using rule 27 (type -> DOUBLE .)


state 7

    (1) program -> variables methods . MAIN LBRACE severalstatutes RBRACE

    MAIN            shift and go to state 11


state 8

    (28) methods -> METHOD . ID LPAREN RPAREN LBRACE severalstatutes RBRACE methods

    ID              shift and go to state 12


state 9

    (29) methods -> empty .

    MAIN            reduce using rule 29 (methods -> empty .)


state 10

    (21) variables -> type ID . SEMICOLON variables
    (22) variables -> type ID . dimensions SEMICOLON
    (24) dimensions -> . LBRACKET idconst RBRACKET dimensions
    (25) dimensions -> . LBRACKET idconst RBRACKET

    SEMICOLON       shift and go to state 13
    LBRACKET        shift and go to state 15

    dimensions                     shift and go to state 14

state 11

    (1) program -> variables methods MAIN . LBRACE severalstatutes RBRACE

    LBRACE          shift and go to state 16


state 12

    (28) methods -> METHOD ID . LPAREN RPAREN LBRACE severalstatutes RBRACE methods

    LPAREN          shift and go to state 17


state 13

    (21) variables -> type ID SEMICOLON . variables
    (21) variables -> . type ID SEMICOLON variables
    (22) variables -> . type ID dimensions SEMICOLON
    (23) variables -> . empty
    (26) type -> . INT
    (27) type -> . DOUBLE
    (57) empty -> .

    INT             shift and go to state 5
    DOUBLE          shift and go to state 6
    METHOD          reduce using rule 57 (empty -> .)
    MAIN            reduce using rule 57 (empty -> .)

    type                           shift and go to state 3
    variables                      shift and go to state 18
    empty                          shift and go to state 4

state 14

    (22) variables -> type ID dimensions . SEMICOLON

    SEMICOLON       shift and go to state 19


state 15

    (24) dimensions -> LBRACKET . idconst RBRACKET dimensions
    (25) dimensions -> LBRACKET . idconst RBRACKET
    (55) idconst -> . ID
    (56) idconst -> . CONST

    ID              shift and go to state 21
    CONST           shift and go to state 22

    idconst                        shift and go to state 20

state 16

    (1) program -> variables methods MAIN LBRACE . severalstatutes RBRACE
    (15) severalstatutes -> . statutes severalstatutes
    (16) severalstatutes -> . statutes
    (17) severalstatutes -> . empty
    (2) statutes -> . conditional
    (3) statutes -> . editvariables
    (4) statutes -> . cyclical
    (5) statutes -> . calling
    (6) statutes -> . readwrite
    (57) empty -> .
    (13) conditional -> . IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE
    (14) conditional -> . IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE ELSE LBRACE severalstatutes RBRACE
    (7) editvariables -> . ID ASSIGN arithexp SEMICOLON
    (8) editvariables -> . ID dimensions ASSIGN arithexp SEMICOLON
    (9) editvariables -> . selectid PLUSPLUS SEMICOLON
    (10) editvariables -> . selectid MINUSMINUS SEMICOLON
    (18) cyclical -> . DO LBRACE severalstatutes RBRACE WHILE LPAREN logicexp RPAREN
    (19) cyclical -> . WHILE LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE
    (20) cyclical -> . FOR LPAREN ID ASSIGN CONST SEMICOLON logicexp SEMICOLON arithexp RPAREN LBRACE severalstatutes RBRACE
    (30) calling -> . CALL ID LPAREN RPAREN SEMICOLON
    (31) readwrite -> . READ LPAREN idreadingloop RPAREN SEMICOLON
    (32) readwrite -> . WRITE LPAREN writecontent RPAREN SEMICOLON
    (11) selectid -> . ID
    (12) selectid -> . ID dimensions

    RBRACE          reduce using rule 57 (empty -> .)
    IF              shift and go to state 31
    ID              shift and go to state 32
    DO              shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    CALL            shift and go to state 37
    READ            shift and go to state 38
    WRITE           shift and go to state 39

    severalstatutes                shift and go to state 23
    statutes                       shift and go to state 24
    empty                          shift and go to state 25
    conditional                    shift and go to state 26
    editvariables                  shift and go to state 27
    cyclical                       shift and go to state 28
    calling                        shift and go to state 29
    readwrite                      shift and go to state 30
    selectid                       shift and go to state 33

state 17

    (28) methods -> METHOD ID LPAREN . RPAREN LBRACE severalstatutes RBRACE methods

    RPAREN          shift and go to state 40


state 18

    (21) variables -> type ID SEMICOLON variables .

    METHOD          reduce using rule 21 (variables -> type ID SEMICOLON variables .)
    MAIN            reduce using rule 21 (variables -> type ID SEMICOLON variables .)


state 19

    (22) variables -> type ID dimensions SEMICOLON .

    METHOD          reduce using rule 22 (variables -> type ID dimensions SEMICOLON .)
    MAIN            reduce using rule 22 (variables -> type ID dimensions SEMICOLON .)


state 20

    (24) dimensions -> LBRACKET idconst . RBRACKET dimensions
    (25) dimensions -> LBRACKET idconst . RBRACKET

    RBRACKET        shift and go to state 41


state 21

    (55) idconst -> ID .

    RBRACKET        reduce using rule 55 (idconst -> ID .)
    LESSTHAN        reduce using rule 55 (idconst -> ID .)
    GREATERTHAN     reduce using rule 55 (idconst -> ID .)
    EQUALS          reduce using rule 55 (idconst -> ID .)
    AND             reduce using rule 55 (idconst -> ID .)
    OR              reduce using rule 55 (idconst -> ID .)
    RPAREN          reduce using rule 55 (idconst -> ID .)
    SEMICOLON       reduce using rule 55 (idconst -> ID .)


state 22

    (56) idconst -> CONST .

    RBRACKET        reduce using rule 56 (idconst -> CONST .)
    LESSTHAN        reduce using rule 56 (idconst -> CONST .)
    GREATERTHAN     reduce using rule 56 (idconst -> CONST .)
    EQUALS          reduce using rule 56 (idconst -> CONST .)
    TIMES           reduce using rule 56 (idconst -> CONST .)
    DIVISION        reduce using rule 56 (idconst -> CONST .)
    PLUS            reduce using rule 56 (idconst -> CONST .)
    MINUS           reduce using rule 56 (idconst -> CONST .)
    SEMICOLON       reduce using rule 56 (idconst -> CONST .)
    RPAREN          reduce using rule 56 (idconst -> CONST .)
    AND             reduce using rule 56 (idconst -> CONST .)
    OR              reduce using rule 56 (idconst -> CONST .)


state 23

    (1) program -> variables methods MAIN LBRACE severalstatutes . RBRACE

    RBRACE          shift and go to state 42


state 24

    (15) severalstatutes -> statutes . severalstatutes
    (16) severalstatutes -> statutes .
    (15) severalstatutes -> . statutes severalstatutes
    (16) severalstatutes -> . statutes
    (17) severalstatutes -> . empty
    (2) statutes -> . conditional
    (3) statutes -> . editvariables
    (4) statutes -> . cyclical
    (5) statutes -> . calling
    (6) statutes -> . readwrite
    (57) empty -> .
    (13) conditional -> . IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE
    (14) conditional -> . IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE ELSE LBRACE severalstatutes RBRACE
    (7) editvariables -> . ID ASSIGN arithexp SEMICOLON
    (8) editvariables -> . ID dimensions ASSIGN arithexp SEMICOLON
    (9) editvariables -> . selectid PLUSPLUS SEMICOLON
    (10) editvariables -> . selectid MINUSMINUS SEMICOLON
    (18) cyclical -> . DO LBRACE severalstatutes RBRACE WHILE LPAREN logicexp RPAREN
    (19) cyclical -> . WHILE LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE
    (20) cyclical -> . FOR LPAREN ID ASSIGN CONST SEMICOLON logicexp SEMICOLON arithexp RPAREN LBRACE severalstatutes RBRACE
    (30) calling -> . CALL ID LPAREN RPAREN SEMICOLON
    (31) readwrite -> . READ LPAREN idreadingloop RPAREN SEMICOLON
    (32) readwrite -> . WRITE LPAREN writecontent RPAREN SEMICOLON
    (11) selectid -> . ID
    (12) selectid -> . ID dimensions

  ! reduce/reduce conflict for RBRACE resolved using rule 16 (severalstatutes -> statutes .)
    RBRACE          reduce using rule 16 (severalstatutes -> statutes .)
    IF              shift and go to state 31
    ID              shift and go to state 32
    DO              shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    CALL            shift and go to state 37
    READ            shift and go to state 38
    WRITE           shift and go to state 39

  ! RBRACE          [ reduce using rule 57 (empty -> .) ]

    statutes                       shift and go to state 24
    severalstatutes                shift and go to state 43
    empty                          shift and go to state 25
    conditional                    shift and go to state 26
    editvariables                  shift and go to state 27
    cyclical                       shift and go to state 28
    calling                        shift and go to state 29
    readwrite                      shift and go to state 30
    selectid                       shift and go to state 33

state 25

    (17) severalstatutes -> empty .

    RBRACE          reduce using rule 17 (severalstatutes -> empty .)


state 26

    (2) statutes -> conditional .

    IF              reduce using rule 2 (statutes -> conditional .)
    ID              reduce using rule 2 (statutes -> conditional .)
    DO              reduce using rule 2 (statutes -> conditional .)
    WHILE           reduce using rule 2 (statutes -> conditional .)
    FOR             reduce using rule 2 (statutes -> conditional .)
    CALL            reduce using rule 2 (statutes -> conditional .)
    READ            reduce using rule 2 (statutes -> conditional .)
    WRITE           reduce using rule 2 (statutes -> conditional .)
    RBRACE          reduce using rule 2 (statutes -> conditional .)


state 27

    (3) statutes -> editvariables .

    IF              reduce using rule 3 (statutes -> editvariables .)
    ID              reduce using rule 3 (statutes -> editvariables .)
    DO              reduce using rule 3 (statutes -> editvariables .)
    WHILE           reduce using rule 3 (statutes -> editvariables .)
    FOR             reduce using rule 3 (statutes -> editvariables .)
    CALL            reduce using rule 3 (statutes -> editvariables .)
    READ            reduce using rule 3 (statutes -> editvariables .)
    WRITE           reduce using rule 3 (statutes -> editvariables .)
    RBRACE          reduce using rule 3 (statutes -> editvariables .)


state 28

    (4) statutes -> cyclical .

    IF              reduce using rule 4 (statutes -> cyclical .)
    ID              reduce using rule 4 (statutes -> cyclical .)
    DO              reduce using rule 4 (statutes -> cyclical .)
    WHILE           reduce using rule 4 (statutes -> cyclical .)
    FOR             reduce using rule 4 (statutes -> cyclical .)
    CALL            reduce using rule 4 (statutes -> cyclical .)
    READ            reduce using rule 4 (statutes -> cyclical .)
    WRITE           reduce using rule 4 (statutes -> cyclical .)
    RBRACE          reduce using rule 4 (statutes -> cyclical .)


state 29

    (5) statutes -> calling .

    IF              reduce using rule 5 (statutes -> calling .)
    ID              reduce using rule 5 (statutes -> calling .)
    DO              reduce using rule 5 (statutes -> calling .)
    WHILE           reduce using rule 5 (statutes -> calling .)
    FOR             reduce using rule 5 (statutes -> calling .)
    CALL            reduce using rule 5 (statutes -> calling .)
    READ            reduce using rule 5 (statutes -> calling .)
    WRITE           reduce using rule 5 (statutes -> calling .)
    RBRACE          reduce using rule 5 (statutes -> calling .)


state 30

    (6) statutes -> readwrite .

    IF              reduce using rule 6 (statutes -> readwrite .)
    ID              reduce using rule 6 (statutes -> readwrite .)
    DO              reduce using rule 6 (statutes -> readwrite .)
    WHILE           reduce using rule 6 (statutes -> readwrite .)
    FOR             reduce using rule 6 (statutes -> readwrite .)
    CALL            reduce using rule 6 (statutes -> readwrite .)
    READ            reduce using rule 6 (statutes -> readwrite .)
    WRITE           reduce using rule 6 (statutes -> readwrite .)
    RBRACE          reduce using rule 6 (statutes -> readwrite .)


state 31

    (13) conditional -> IF . LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE
    (14) conditional -> IF . LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE ELSE LBRACE severalstatutes RBRACE

    LPAREN          shift and go to state 44


state 32

    (7) editvariables -> ID . ASSIGN arithexp SEMICOLON
    (8) editvariables -> ID . dimensions ASSIGN arithexp SEMICOLON
    (11) selectid -> ID .
    (12) selectid -> ID . dimensions
    (24) dimensions -> . LBRACKET idconst RBRACKET dimensions
    (25) dimensions -> . LBRACKET idconst RBRACKET

    ASSIGN          shift and go to state 45
    PLUSPLUS        reduce using rule 11 (selectid -> ID .)
    MINUSMINUS      reduce using rule 11 (selectid -> ID .)
    LBRACKET        shift and go to state 15

    dimensions                     shift and go to state 46

state 33

    (9) editvariables -> selectid . PLUSPLUS SEMICOLON
    (10) editvariables -> selectid . MINUSMINUS SEMICOLON

    PLUSPLUS        shift and go to state 47
    MINUSMINUS      shift and go to state 48


state 34

    (18) cyclical -> DO . LBRACE severalstatutes RBRACE WHILE LPAREN logicexp RPAREN

    LBRACE          shift and go to state 49


state 35

    (19) cyclical -> WHILE . LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE

    LPAREN          shift and go to state 50


state 36

    (20) cyclical -> FOR . LPAREN ID ASSIGN CONST SEMICOLON logicexp SEMICOLON arithexp RPAREN LBRACE severalstatutes RBRACE

    LPAREN          shift and go to state 51


state 37

    (30) calling -> CALL . ID LPAREN RPAREN SEMICOLON

    ID              shift and go to state 52


state 38

    (31) readwrite -> READ . LPAREN idreadingloop RPAREN SEMICOLON

    LPAREN          shift and go to state 53


state 39

    (32) readwrite -> WRITE . LPAREN writecontent RPAREN SEMICOLON

    LPAREN          shift and go to state 54


state 40

    (28) methods -> METHOD ID LPAREN RPAREN . LBRACE severalstatutes RBRACE methods

    LBRACE          shift and go to state 55


state 41

    (24) dimensions -> LBRACKET idconst RBRACKET . dimensions
    (25) dimensions -> LBRACKET idconst RBRACKET .
    (24) dimensions -> . LBRACKET idconst RBRACKET dimensions
    (25) dimensions -> . LBRACKET idconst RBRACKET

    SEMICOLON       reduce using rule 25 (dimensions -> LBRACKET idconst RBRACKET .)
    ASSIGN          reduce using rule 25 (dimensions -> LBRACKET idconst RBRACKET .)
    PLUSPLUS        reduce using rule 25 (dimensions -> LBRACKET idconst RBRACKET .)
    MINUSMINUS      reduce using rule 25 (dimensions -> LBRACKET idconst RBRACKET .)
    LBRACKET        shift and go to state 15

    dimensions                     shift and go to state 56

state 42

    (1) program -> variables methods MAIN LBRACE severalstatutes RBRACE .

    $end            reduce using rule 1 (program -> variables methods MAIN LBRACE severalstatutes RBRACE .)


state 43

    (15) severalstatutes -> statutes severalstatutes .

    RBRACE          reduce using rule 15 (severalstatutes -> statutes severalstatutes .)


state 44

    (13) conditional -> IF LPAREN . logicexp RPAREN LBRACE severalstatutes RBRACE
    (14) conditional -> IF LPAREN . logicexp RPAREN LBRACE severalstatutes RBRACE ELSE LBRACE severalstatutes RBRACE
    (47) logicexp -> . logicterm
    (48) logicexp -> . logicterm OR logicexp
    (49) logicterm -> . logicfunction
    (50) logicterm -> . logicfunction AND logicterm
    (51) logicfunction -> . idconst LESSTHAN idconst
    (52) logicfunction -> . idconst GREATERTHAN idconst
    (53) logicfunction -> . idconst EQUALS idconst
    (54) logicfunction -> . LPAREN logicexp RPAREN
    (55) idconst -> . ID
    (56) idconst -> . CONST

    LPAREN          shift and go to state 57
    ID              shift and go to state 21
    CONST           shift and go to state 22

    logicexp                       shift and go to state 58
    logicterm                      shift and go to state 59
    logicfunction                  shift and go to state 60
    idconst                        shift and go to state 61

state 45

    (7) editvariables -> ID ASSIGN . arithexp SEMICOLON
    (37) arithexp -> . arithterm
    (38) arithexp -> . arithterm PLUS arithexp
    (39) arithexp -> . arithterm MINUS arithexp
    (40) arithterm -> . arithfunction
    (41) arithterm -> . arithfunction TIMES arithterm
    (42) arithterm -> . arithfunction DIVISION arithterm
    (43) arithfunction -> . idconst
    (44) arithfunction -> . ID PLUSPLUS
    (45) arithfunction -> . ID MINUSMINUS
    (46) arithfunction -> . LPAREN arithexp RPAREN
    (55) idconst -> . ID
    (56) idconst -> . CONST

    ID              shift and go to state 62
    LPAREN          shift and go to state 67
    CONST           shift and go to state 22

    arithexp                       shift and go to state 63
    arithterm                      shift and go to state 64
    arithfunction                  shift and go to state 65
    idconst                        shift and go to state 66

state 46

    (8) editvariables -> ID dimensions . ASSIGN arithexp SEMICOLON
    (12) selectid -> ID dimensions .

    ASSIGN          shift and go to state 68
    PLUSPLUS        reduce using rule 12 (selectid -> ID dimensions .)
    MINUSMINUS      reduce using rule 12 (selectid -> ID dimensions .)


state 47

    (9) editvariables -> selectid PLUSPLUS . SEMICOLON

    SEMICOLON       shift and go to state 69


state 48

    (10) editvariables -> selectid MINUSMINUS . SEMICOLON

    SEMICOLON       shift and go to state 70


state 49

    (18) cyclical -> DO LBRACE . severalstatutes RBRACE WHILE LPAREN logicexp RPAREN
    (15) severalstatutes -> . statutes severalstatutes
    (16) severalstatutes -> . statutes
    (17) severalstatutes -> . empty
    (2) statutes -> . conditional
    (3) statutes -> . editvariables
    (4) statutes -> . cyclical
    (5) statutes -> . calling
    (6) statutes -> . readwrite
    (57) empty -> .
    (13) conditional -> . IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE
    (14) conditional -> . IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE ELSE LBRACE severalstatutes RBRACE
    (7) editvariables -> . ID ASSIGN arithexp SEMICOLON
    (8) editvariables -> . ID dimensions ASSIGN arithexp SEMICOLON
    (9) editvariables -> . selectid PLUSPLUS SEMICOLON
    (10) editvariables -> . selectid MINUSMINUS SEMICOLON
    (18) cyclical -> . DO LBRACE severalstatutes RBRACE WHILE LPAREN logicexp RPAREN
    (19) cyclical -> . WHILE LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE
    (20) cyclical -> . FOR LPAREN ID ASSIGN CONST SEMICOLON logicexp SEMICOLON arithexp RPAREN LBRACE severalstatutes RBRACE
    (30) calling -> . CALL ID LPAREN RPAREN SEMICOLON
    (31) readwrite -> . READ LPAREN idreadingloop RPAREN SEMICOLON
    (32) readwrite -> . WRITE LPAREN writecontent RPAREN SEMICOLON
    (11) selectid -> . ID
    (12) selectid -> . ID dimensions

    RBRACE          reduce using rule 57 (empty -> .)
    IF              shift and go to state 31
    ID              shift and go to state 32
    DO              shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    CALL            shift and go to state 37
    READ            shift and go to state 38
    WRITE           shift and go to state 39

    severalstatutes                shift and go to state 71
    statutes                       shift and go to state 24
    empty                          shift and go to state 25
    conditional                    shift and go to state 26
    editvariables                  shift and go to state 27
    cyclical                       shift and go to state 28
    calling                        shift and go to state 29
    readwrite                      shift and go to state 30
    selectid                       shift and go to state 33

state 50

    (19) cyclical -> WHILE LPAREN . logicexp RPAREN LBRACE severalstatutes RBRACE
    (47) logicexp -> . logicterm
    (48) logicexp -> . logicterm OR logicexp
    (49) logicterm -> . logicfunction
    (50) logicterm -> . logicfunction AND logicterm
    (51) logicfunction -> . idconst LESSTHAN idconst
    (52) logicfunction -> . idconst GREATERTHAN idconst
    (53) logicfunction -> . idconst EQUALS idconst
    (54) logicfunction -> . LPAREN logicexp RPAREN
    (55) idconst -> . ID
    (56) idconst -> . CONST

    LPAREN          shift and go to state 57
    ID              shift and go to state 21
    CONST           shift and go to state 22

    logicexp                       shift and go to state 72
    logicterm                      shift and go to state 59
    logicfunction                  shift and go to state 60
    idconst                        shift and go to state 61

state 51

    (20) cyclical -> FOR LPAREN . ID ASSIGN CONST SEMICOLON logicexp SEMICOLON arithexp RPAREN LBRACE severalstatutes RBRACE

    ID              shift and go to state 73


state 52

    (30) calling -> CALL ID . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 74


state 53

    (31) readwrite -> READ LPAREN . idreadingloop RPAREN SEMICOLON
    (33) idreadingloop -> . ID COMA idreadingloop
    (34) idreadingloop -> . ID

    ID              shift and go to state 76

    idreadingloop                  shift and go to state 75

state 54

    (32) readwrite -> WRITE LPAREN . writecontent RPAREN SEMICOLON
    (35) writecontent -> . arithfunction
    (36) writecontent -> . logicfunction
    (43) arithfunction -> . idconst
    (44) arithfunction -> . ID PLUSPLUS
    (45) arithfunction -> . ID MINUSMINUS
    (46) arithfunction -> . LPAREN arithexp RPAREN
    (51) logicfunction -> . idconst LESSTHAN idconst
    (52) logicfunction -> . idconst GREATERTHAN idconst
    (53) logicfunction -> . idconst EQUALS idconst
    (54) logicfunction -> . LPAREN logicexp RPAREN
    (55) idconst -> . ID
    (56) idconst -> . CONST

    ID              shift and go to state 62
    LPAREN          shift and go to state 77
    CONST           shift and go to state 22

    writecontent                   shift and go to state 78
    arithfunction                  shift and go to state 79
    logicfunction                  shift and go to state 80
    idconst                        shift and go to state 81

state 55

    (28) methods -> METHOD ID LPAREN RPAREN LBRACE . severalstatutes RBRACE methods
    (15) severalstatutes -> . statutes severalstatutes
    (16) severalstatutes -> . statutes
    (17) severalstatutes -> . empty
    (2) statutes -> . conditional
    (3) statutes -> . editvariables
    (4) statutes -> . cyclical
    (5) statutes -> . calling
    (6) statutes -> . readwrite
    (57) empty -> .
    (13) conditional -> . IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE
    (14) conditional -> . IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE ELSE LBRACE severalstatutes RBRACE
    (7) editvariables -> . ID ASSIGN arithexp SEMICOLON
    (8) editvariables -> . ID dimensions ASSIGN arithexp SEMICOLON
    (9) editvariables -> . selectid PLUSPLUS SEMICOLON
    (10) editvariables -> . selectid MINUSMINUS SEMICOLON
    (18) cyclical -> . DO LBRACE severalstatutes RBRACE WHILE LPAREN logicexp RPAREN
    (19) cyclical -> . WHILE LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE
    (20) cyclical -> . FOR LPAREN ID ASSIGN CONST SEMICOLON logicexp SEMICOLON arithexp RPAREN LBRACE severalstatutes RBRACE
    (30) calling -> . CALL ID LPAREN RPAREN SEMICOLON
    (31) readwrite -> . READ LPAREN idreadingloop RPAREN SEMICOLON
    (32) readwrite -> . WRITE LPAREN writecontent RPAREN SEMICOLON
    (11) selectid -> . ID
    (12) selectid -> . ID dimensions

    RBRACE          reduce using rule 57 (empty -> .)
    IF              shift and go to state 31
    ID              shift and go to state 32
    DO              shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    CALL            shift and go to state 37
    READ            shift and go to state 38
    WRITE           shift and go to state 39

    severalstatutes                shift and go to state 82
    statutes                       shift and go to state 24
    empty                          shift and go to state 25
    conditional                    shift and go to state 26
    editvariables                  shift and go to state 27
    cyclical                       shift and go to state 28
    calling                        shift and go to state 29
    readwrite                      shift and go to state 30
    selectid                       shift and go to state 33

state 56

    (24) dimensions -> LBRACKET idconst RBRACKET dimensions .

    SEMICOLON       reduce using rule 24 (dimensions -> LBRACKET idconst RBRACKET dimensions .)
    ASSIGN          reduce using rule 24 (dimensions -> LBRACKET idconst RBRACKET dimensions .)
    PLUSPLUS        reduce using rule 24 (dimensions -> LBRACKET idconst RBRACKET dimensions .)
    MINUSMINUS      reduce using rule 24 (dimensions -> LBRACKET idconst RBRACKET dimensions .)


state 57

    (54) logicfunction -> LPAREN . logicexp RPAREN
    (47) logicexp -> . logicterm
    (48) logicexp -> . logicterm OR logicexp
    (49) logicterm -> . logicfunction
    (50) logicterm -> . logicfunction AND logicterm
    (51) logicfunction -> . idconst LESSTHAN idconst
    (52) logicfunction -> . idconst GREATERTHAN idconst
    (53) logicfunction -> . idconst EQUALS idconst
    (54) logicfunction -> . LPAREN logicexp RPAREN
    (55) idconst -> . ID
    (56) idconst -> . CONST

    LPAREN          shift and go to state 57
    ID              shift and go to state 21
    CONST           shift and go to state 22

    logicexp                       shift and go to state 83
    logicterm                      shift and go to state 59
    logicfunction                  shift and go to state 60
    idconst                        shift and go to state 61

state 58

    (13) conditional -> IF LPAREN logicexp . RPAREN LBRACE severalstatutes RBRACE
    (14) conditional -> IF LPAREN logicexp . RPAREN LBRACE severalstatutes RBRACE ELSE LBRACE severalstatutes RBRACE

    RPAREN          shift and go to state 84


state 59

    (47) logicexp -> logicterm .
    (48) logicexp -> logicterm . OR logicexp

    RPAREN          reduce using rule 47 (logicexp -> logicterm .)
    SEMICOLON       reduce using rule 47 (logicexp -> logicterm .)
    OR              shift and go to state 85


state 60

    (49) logicterm -> logicfunction .
    (50) logicterm -> logicfunction . AND logicterm

    OR              reduce using rule 49 (logicterm -> logicfunction .)
    RPAREN          reduce using rule 49 (logicterm -> logicfunction .)
    SEMICOLON       reduce using rule 49 (logicterm -> logicfunction .)
    AND             shift and go to state 86


state 61

    (51) logicfunction -> idconst . LESSTHAN idconst
    (52) logicfunction -> idconst . GREATERTHAN idconst
    (53) logicfunction -> idconst . EQUALS idconst

    LESSTHAN        shift and go to state 87
    GREATERTHAN     shift and go to state 88
    EQUALS          shift and go to state 89


state 62

    (44) arithfunction -> ID . PLUSPLUS
    (45) arithfunction -> ID . MINUSMINUS
    (55) idconst -> ID .

    PLUSPLUS        shift and go to state 90
    MINUSMINUS      shift and go to state 91
    TIMES           reduce using rule 55 (idconst -> ID .)
    DIVISION        reduce using rule 55 (idconst -> ID .)
    PLUS            reduce using rule 55 (idconst -> ID .)
    MINUS           reduce using rule 55 (idconst -> ID .)
    SEMICOLON       reduce using rule 55 (idconst -> ID .)
    LESSTHAN        reduce using rule 55 (idconst -> ID .)
    GREATERTHAN     reduce using rule 55 (idconst -> ID .)
    EQUALS          reduce using rule 55 (idconst -> ID .)
    RPAREN          reduce using rule 55 (idconst -> ID .)


state 63

    (7) editvariables -> ID ASSIGN arithexp . SEMICOLON

    SEMICOLON       shift and go to state 92


state 64

    (37) arithexp -> arithterm .
    (38) arithexp -> arithterm . PLUS arithexp
    (39) arithexp -> arithterm . MINUS arithexp

    SEMICOLON       reduce using rule 37 (arithexp -> arithterm .)
    RPAREN          reduce using rule 37 (arithexp -> arithterm .)
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94


state 65

    (40) arithterm -> arithfunction .
    (41) arithterm -> arithfunction . TIMES arithterm
    (42) arithterm -> arithfunction . DIVISION arithterm

    PLUS            reduce using rule 40 (arithterm -> arithfunction .)
    MINUS           reduce using rule 40 (arithterm -> arithfunction .)
    SEMICOLON       reduce using rule 40 (arithterm -> arithfunction .)
    RPAREN          reduce using rule 40 (arithterm -> arithfunction .)
    TIMES           shift and go to state 95
    DIVISION        shift and go to state 96


state 66

    (43) arithfunction -> idconst .

    TIMES           reduce using rule 43 (arithfunction -> idconst .)
    DIVISION        reduce using rule 43 (arithfunction -> idconst .)
    PLUS            reduce using rule 43 (arithfunction -> idconst .)
    MINUS           reduce using rule 43 (arithfunction -> idconst .)
    SEMICOLON       reduce using rule 43 (arithfunction -> idconst .)
    RPAREN          reduce using rule 43 (arithfunction -> idconst .)


state 67

    (46) arithfunction -> LPAREN . arithexp RPAREN
    (37) arithexp -> . arithterm
    (38) arithexp -> . arithterm PLUS arithexp
    (39) arithexp -> . arithterm MINUS arithexp
    (40) arithterm -> . arithfunction
    (41) arithterm -> . arithfunction TIMES arithterm
    (42) arithterm -> . arithfunction DIVISION arithterm
    (43) arithfunction -> . idconst
    (44) arithfunction -> . ID PLUSPLUS
    (45) arithfunction -> . ID MINUSMINUS
    (46) arithfunction -> . LPAREN arithexp RPAREN
    (55) idconst -> . ID
    (56) idconst -> . CONST

    ID              shift and go to state 62
    LPAREN          shift and go to state 67
    CONST           shift and go to state 22

    arithexp                       shift and go to state 97
    arithterm                      shift and go to state 64
    arithfunction                  shift and go to state 65
    idconst                        shift and go to state 66

state 68

    (8) editvariables -> ID dimensions ASSIGN . arithexp SEMICOLON
    (37) arithexp -> . arithterm
    (38) arithexp -> . arithterm PLUS arithexp
    (39) arithexp -> . arithterm MINUS arithexp
    (40) arithterm -> . arithfunction
    (41) arithterm -> . arithfunction TIMES arithterm
    (42) arithterm -> . arithfunction DIVISION arithterm
    (43) arithfunction -> . idconst
    (44) arithfunction -> . ID PLUSPLUS
    (45) arithfunction -> . ID MINUSMINUS
    (46) arithfunction -> . LPAREN arithexp RPAREN
    (55) idconst -> . ID
    (56) idconst -> . CONST

    ID              shift and go to state 62
    LPAREN          shift and go to state 67
    CONST           shift and go to state 22

    arithexp                       shift and go to state 98
    arithterm                      shift and go to state 64
    arithfunction                  shift and go to state 65
    idconst                        shift and go to state 66

state 69

    (9) editvariables -> selectid PLUSPLUS SEMICOLON .

    IF              reduce using rule 9 (editvariables -> selectid PLUSPLUS SEMICOLON .)
    ID              reduce using rule 9 (editvariables -> selectid PLUSPLUS SEMICOLON .)
    DO              reduce using rule 9 (editvariables -> selectid PLUSPLUS SEMICOLON .)
    WHILE           reduce using rule 9 (editvariables -> selectid PLUSPLUS SEMICOLON .)
    FOR             reduce using rule 9 (editvariables -> selectid PLUSPLUS SEMICOLON .)
    CALL            reduce using rule 9 (editvariables -> selectid PLUSPLUS SEMICOLON .)
    READ            reduce using rule 9 (editvariables -> selectid PLUSPLUS SEMICOLON .)
    WRITE           reduce using rule 9 (editvariables -> selectid PLUSPLUS SEMICOLON .)
    RBRACE          reduce using rule 9 (editvariables -> selectid PLUSPLUS SEMICOLON .)


state 70

    (10) editvariables -> selectid MINUSMINUS SEMICOLON .

    IF              reduce using rule 10 (editvariables -> selectid MINUSMINUS SEMICOLON .)
    ID              reduce using rule 10 (editvariables -> selectid MINUSMINUS SEMICOLON .)
    DO              reduce using rule 10 (editvariables -> selectid MINUSMINUS SEMICOLON .)
    WHILE           reduce using rule 10 (editvariables -> selectid MINUSMINUS SEMICOLON .)
    FOR             reduce using rule 10 (editvariables -> selectid MINUSMINUS SEMICOLON .)
    CALL            reduce using rule 10 (editvariables -> selectid MINUSMINUS SEMICOLON .)
    READ            reduce using rule 10 (editvariables -> selectid MINUSMINUS SEMICOLON .)
    WRITE           reduce using rule 10 (editvariables -> selectid MINUSMINUS SEMICOLON .)
    RBRACE          reduce using rule 10 (editvariables -> selectid MINUSMINUS SEMICOLON .)


state 71

    (18) cyclical -> DO LBRACE severalstatutes . RBRACE WHILE LPAREN logicexp RPAREN

    RBRACE          shift and go to state 99


state 72

    (19) cyclical -> WHILE LPAREN logicexp . RPAREN LBRACE severalstatutes RBRACE

    RPAREN          shift and go to state 100


state 73

    (20) cyclical -> FOR LPAREN ID . ASSIGN CONST SEMICOLON logicexp SEMICOLON arithexp RPAREN LBRACE severalstatutes RBRACE

    ASSIGN          shift and go to state 101


state 74

    (30) calling -> CALL ID LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 102


state 75

    (31) readwrite -> READ LPAREN idreadingloop . RPAREN SEMICOLON

    RPAREN          shift and go to state 103


state 76

    (33) idreadingloop -> ID . COMA idreadingloop
    (34) idreadingloop -> ID .

    COMA            shift and go to state 104
    RPAREN          reduce using rule 34 (idreadingloop -> ID .)


state 77

    (46) arithfunction -> LPAREN . arithexp RPAREN
    (54) logicfunction -> LPAREN . logicexp RPAREN
    (37) arithexp -> . arithterm
    (38) arithexp -> . arithterm PLUS arithexp
    (39) arithexp -> . arithterm MINUS arithexp
    (47) logicexp -> . logicterm
    (48) logicexp -> . logicterm OR logicexp
    (40) arithterm -> . arithfunction
    (41) arithterm -> . arithfunction TIMES arithterm
    (42) arithterm -> . arithfunction DIVISION arithterm
    (49) logicterm -> . logicfunction
    (50) logicterm -> . logicfunction AND logicterm
    (43) arithfunction -> . idconst
    (44) arithfunction -> . ID PLUSPLUS
    (45) arithfunction -> . ID MINUSMINUS
    (46) arithfunction -> . LPAREN arithexp RPAREN
    (51) logicfunction -> . idconst LESSTHAN idconst
    (52) logicfunction -> . idconst GREATERTHAN idconst
    (53) logicfunction -> . idconst EQUALS idconst
    (54) logicfunction -> . LPAREN logicexp RPAREN
    (55) idconst -> . ID
    (56) idconst -> . CONST

    ID              shift and go to state 62
    LPAREN          shift and go to state 77
    CONST           shift and go to state 22

    arithexp                       shift and go to state 97
    logicexp                       shift and go to state 83
    arithterm                      shift and go to state 64
    logicterm                      shift and go to state 59
    arithfunction                  shift and go to state 65
    logicfunction                  shift and go to state 60
    idconst                        shift and go to state 81

state 78

    (32) readwrite -> WRITE LPAREN writecontent . RPAREN SEMICOLON

    RPAREN          shift and go to state 105


state 79

    (35) writecontent -> arithfunction .

    RPAREN          reduce using rule 35 (writecontent -> arithfunction .)


state 80

    (36) writecontent -> logicfunction .

    RPAREN          reduce using rule 36 (writecontent -> logicfunction .)


state 81

    (43) arithfunction -> idconst .
    (51) logicfunction -> idconst . LESSTHAN idconst
    (52) logicfunction -> idconst . GREATERTHAN idconst
    (53) logicfunction -> idconst . EQUALS idconst

    RPAREN          reduce using rule 43 (arithfunction -> idconst .)
    TIMES           reduce using rule 43 (arithfunction -> idconst .)
    DIVISION        reduce using rule 43 (arithfunction -> idconst .)
    PLUS            reduce using rule 43 (arithfunction -> idconst .)
    MINUS           reduce using rule 43 (arithfunction -> idconst .)
    LESSTHAN        shift and go to state 87
    GREATERTHAN     shift and go to state 88
    EQUALS          shift and go to state 89


state 82

    (28) methods -> METHOD ID LPAREN RPAREN LBRACE severalstatutes . RBRACE methods

    RBRACE          shift and go to state 106


state 83

    (54) logicfunction -> LPAREN logicexp . RPAREN

    RPAREN          shift and go to state 107


state 84

    (13) conditional -> IF LPAREN logicexp RPAREN . LBRACE severalstatutes RBRACE
    (14) conditional -> IF LPAREN logicexp RPAREN . LBRACE severalstatutes RBRACE ELSE LBRACE severalstatutes RBRACE

    LBRACE          shift and go to state 108


state 85

    (48) logicexp -> logicterm OR . logicexp
    (47) logicexp -> . logicterm
    (48) logicexp -> . logicterm OR logicexp
    (49) logicterm -> . logicfunction
    (50) logicterm -> . logicfunction AND logicterm
    (51) logicfunction -> . idconst LESSTHAN idconst
    (52) logicfunction -> . idconst GREATERTHAN idconst
    (53) logicfunction -> . idconst EQUALS idconst
    (54) logicfunction -> . LPAREN logicexp RPAREN
    (55) idconst -> . ID
    (56) idconst -> . CONST

    LPAREN          shift and go to state 57
    ID              shift and go to state 21
    CONST           shift and go to state 22

    logicterm                      shift and go to state 59
    logicexp                       shift and go to state 109
    logicfunction                  shift and go to state 60
    idconst                        shift and go to state 61

state 86

    (50) logicterm -> logicfunction AND . logicterm
    (49) logicterm -> . logicfunction
    (50) logicterm -> . logicfunction AND logicterm
    (51) logicfunction -> . idconst LESSTHAN idconst
    (52) logicfunction -> . idconst GREATERTHAN idconst
    (53) logicfunction -> . idconst EQUALS idconst
    (54) logicfunction -> . LPAREN logicexp RPAREN
    (55) idconst -> . ID
    (56) idconst -> . CONST

    LPAREN          shift and go to state 57
    ID              shift and go to state 21
    CONST           shift and go to state 22

    logicfunction                  shift and go to state 60
    logicterm                      shift and go to state 110
    idconst                        shift and go to state 61

state 87

    (51) logicfunction -> idconst LESSTHAN . idconst
    (55) idconst -> . ID
    (56) idconst -> . CONST

    ID              shift and go to state 21
    CONST           shift and go to state 22

    idconst                        shift and go to state 111

state 88

    (52) logicfunction -> idconst GREATERTHAN . idconst
    (55) idconst -> . ID
    (56) idconst -> . CONST

    ID              shift and go to state 21
    CONST           shift and go to state 22

    idconst                        shift and go to state 112

state 89

    (53) logicfunction -> idconst EQUALS . idconst
    (55) idconst -> . ID
    (56) idconst -> . CONST

    ID              shift and go to state 21
    CONST           shift and go to state 22

    idconst                        shift and go to state 113

state 90

    (44) arithfunction -> ID PLUSPLUS .

    TIMES           reduce using rule 44 (arithfunction -> ID PLUSPLUS .)
    DIVISION        reduce using rule 44 (arithfunction -> ID PLUSPLUS .)
    PLUS            reduce using rule 44 (arithfunction -> ID PLUSPLUS .)
    MINUS           reduce using rule 44 (arithfunction -> ID PLUSPLUS .)
    SEMICOLON       reduce using rule 44 (arithfunction -> ID PLUSPLUS .)
    RPAREN          reduce using rule 44 (arithfunction -> ID PLUSPLUS .)


state 91

    (45) arithfunction -> ID MINUSMINUS .

    TIMES           reduce using rule 45 (arithfunction -> ID MINUSMINUS .)
    DIVISION        reduce using rule 45 (arithfunction -> ID MINUSMINUS .)
    PLUS            reduce using rule 45 (arithfunction -> ID MINUSMINUS .)
    MINUS           reduce using rule 45 (arithfunction -> ID MINUSMINUS .)
    SEMICOLON       reduce using rule 45 (arithfunction -> ID MINUSMINUS .)
    RPAREN          reduce using rule 45 (arithfunction -> ID MINUSMINUS .)


state 92

    (7) editvariables -> ID ASSIGN arithexp SEMICOLON .

    IF              reduce using rule 7 (editvariables -> ID ASSIGN arithexp SEMICOLON .)
    ID              reduce using rule 7 (editvariables -> ID ASSIGN arithexp SEMICOLON .)
    DO              reduce using rule 7 (editvariables -> ID ASSIGN arithexp SEMICOLON .)
    WHILE           reduce using rule 7 (editvariables -> ID ASSIGN arithexp SEMICOLON .)
    FOR             reduce using rule 7 (editvariables -> ID ASSIGN arithexp SEMICOLON .)
    CALL            reduce using rule 7 (editvariables -> ID ASSIGN arithexp SEMICOLON .)
    READ            reduce using rule 7 (editvariables -> ID ASSIGN arithexp SEMICOLON .)
    WRITE           reduce using rule 7 (editvariables -> ID ASSIGN arithexp SEMICOLON .)
    RBRACE          reduce using rule 7 (editvariables -> ID ASSIGN arithexp SEMICOLON .)


state 93

    (38) arithexp -> arithterm PLUS . arithexp
    (37) arithexp -> . arithterm
    (38) arithexp -> . arithterm PLUS arithexp
    (39) arithexp -> . arithterm MINUS arithexp
    (40) arithterm -> . arithfunction
    (41) arithterm -> . arithfunction TIMES arithterm
    (42) arithterm -> . arithfunction DIVISION arithterm
    (43) arithfunction -> . idconst
    (44) arithfunction -> . ID PLUSPLUS
    (45) arithfunction -> . ID MINUSMINUS
    (46) arithfunction -> . LPAREN arithexp RPAREN
    (55) idconst -> . ID
    (56) idconst -> . CONST

    ID              shift and go to state 62
    LPAREN          shift and go to state 67
    CONST           shift and go to state 22

    arithterm                      shift and go to state 64
    arithexp                       shift and go to state 114
    arithfunction                  shift and go to state 65
    idconst                        shift and go to state 66

state 94

    (39) arithexp -> arithterm MINUS . arithexp
    (37) arithexp -> . arithterm
    (38) arithexp -> . arithterm PLUS arithexp
    (39) arithexp -> . arithterm MINUS arithexp
    (40) arithterm -> . arithfunction
    (41) arithterm -> . arithfunction TIMES arithterm
    (42) arithterm -> . arithfunction DIVISION arithterm
    (43) arithfunction -> . idconst
    (44) arithfunction -> . ID PLUSPLUS
    (45) arithfunction -> . ID MINUSMINUS
    (46) arithfunction -> . LPAREN arithexp RPAREN
    (55) idconst -> . ID
    (56) idconst -> . CONST

    ID              shift and go to state 62
    LPAREN          shift and go to state 67
    CONST           shift and go to state 22

    arithterm                      shift and go to state 64
    arithexp                       shift and go to state 115
    arithfunction                  shift and go to state 65
    idconst                        shift and go to state 66

state 95

    (41) arithterm -> arithfunction TIMES . arithterm
    (40) arithterm -> . arithfunction
    (41) arithterm -> . arithfunction TIMES arithterm
    (42) arithterm -> . arithfunction DIVISION arithterm
    (43) arithfunction -> . idconst
    (44) arithfunction -> . ID PLUSPLUS
    (45) arithfunction -> . ID MINUSMINUS
    (46) arithfunction -> . LPAREN arithexp RPAREN
    (55) idconst -> . ID
    (56) idconst -> . CONST

    ID              shift and go to state 62
    LPAREN          shift and go to state 67
    CONST           shift and go to state 22

    arithfunction                  shift and go to state 65
    arithterm                      shift and go to state 116
    idconst                        shift and go to state 66

state 96

    (42) arithterm -> arithfunction DIVISION . arithterm
    (40) arithterm -> . arithfunction
    (41) arithterm -> . arithfunction TIMES arithterm
    (42) arithterm -> . arithfunction DIVISION arithterm
    (43) arithfunction -> . idconst
    (44) arithfunction -> . ID PLUSPLUS
    (45) arithfunction -> . ID MINUSMINUS
    (46) arithfunction -> . LPAREN arithexp RPAREN
    (55) idconst -> . ID
    (56) idconst -> . CONST

    ID              shift and go to state 62
    LPAREN          shift and go to state 67
    CONST           shift and go to state 22

    arithfunction                  shift and go to state 65
    arithterm                      shift and go to state 117
    idconst                        shift and go to state 66

state 97

    (46) arithfunction -> LPAREN arithexp . RPAREN

    RPAREN          shift and go to state 118


state 98

    (8) editvariables -> ID dimensions ASSIGN arithexp . SEMICOLON

    SEMICOLON       shift and go to state 119


state 99

    (18) cyclical -> DO LBRACE severalstatutes RBRACE . WHILE LPAREN logicexp RPAREN

    WHILE           shift and go to state 120


state 100

    (19) cyclical -> WHILE LPAREN logicexp RPAREN . LBRACE severalstatutes RBRACE

    LBRACE          shift and go to state 121


state 101

    (20) cyclical -> FOR LPAREN ID ASSIGN . CONST SEMICOLON logicexp SEMICOLON arithexp RPAREN LBRACE severalstatutes RBRACE

    CONST           shift and go to state 122


state 102

    (30) calling -> CALL ID LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 123


state 103

    (31) readwrite -> READ LPAREN idreadingloop RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 124


state 104

    (33) idreadingloop -> ID COMA . idreadingloop
    (33) idreadingloop -> . ID COMA idreadingloop
    (34) idreadingloop -> . ID

    ID              shift and go to state 76

    idreadingloop                  shift and go to state 125

state 105

    (32) readwrite -> WRITE LPAREN writecontent RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 126


state 106

    (28) methods -> METHOD ID LPAREN RPAREN LBRACE severalstatutes RBRACE . methods
    (28) methods -> . METHOD ID LPAREN RPAREN LBRACE severalstatutes RBRACE methods
    (29) methods -> . empty
    (57) empty -> .

    METHOD          shift and go to state 8
    MAIN            reduce using rule 57 (empty -> .)

    methods                        shift and go to state 127
    empty                          shift and go to state 9

state 107

    (54) logicfunction -> LPAREN logicexp RPAREN .

    AND             reduce using rule 54 (logicfunction -> LPAREN logicexp RPAREN .)
    OR              reduce using rule 54 (logicfunction -> LPAREN logicexp RPAREN .)
    RPAREN          reduce using rule 54 (logicfunction -> LPAREN logicexp RPAREN .)
    SEMICOLON       reduce using rule 54 (logicfunction -> LPAREN logicexp RPAREN .)


state 108

    (13) conditional -> IF LPAREN logicexp RPAREN LBRACE . severalstatutes RBRACE
    (14) conditional -> IF LPAREN logicexp RPAREN LBRACE . severalstatutes RBRACE ELSE LBRACE severalstatutes RBRACE
    (15) severalstatutes -> . statutes severalstatutes
    (16) severalstatutes -> . statutes
    (17) severalstatutes -> . empty
    (2) statutes -> . conditional
    (3) statutes -> . editvariables
    (4) statutes -> . cyclical
    (5) statutes -> . calling
    (6) statutes -> . readwrite
    (57) empty -> .
    (13) conditional -> . IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE
    (14) conditional -> . IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE ELSE LBRACE severalstatutes RBRACE
    (7) editvariables -> . ID ASSIGN arithexp SEMICOLON
    (8) editvariables -> . ID dimensions ASSIGN arithexp SEMICOLON
    (9) editvariables -> . selectid PLUSPLUS SEMICOLON
    (10) editvariables -> . selectid MINUSMINUS SEMICOLON
    (18) cyclical -> . DO LBRACE severalstatutes RBRACE WHILE LPAREN logicexp RPAREN
    (19) cyclical -> . WHILE LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE
    (20) cyclical -> . FOR LPAREN ID ASSIGN CONST SEMICOLON logicexp SEMICOLON arithexp RPAREN LBRACE severalstatutes RBRACE
    (30) calling -> . CALL ID LPAREN RPAREN SEMICOLON
    (31) readwrite -> . READ LPAREN idreadingloop RPAREN SEMICOLON
    (32) readwrite -> . WRITE LPAREN writecontent RPAREN SEMICOLON
    (11) selectid -> . ID
    (12) selectid -> . ID dimensions

    RBRACE          reduce using rule 57 (empty -> .)
    IF              shift and go to state 31
    ID              shift and go to state 32
    DO              shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    CALL            shift and go to state 37
    READ            shift and go to state 38
    WRITE           shift and go to state 39

    severalstatutes                shift and go to state 128
    statutes                       shift and go to state 24
    empty                          shift and go to state 25
    conditional                    shift and go to state 26
    editvariables                  shift and go to state 27
    cyclical                       shift and go to state 28
    calling                        shift and go to state 29
    readwrite                      shift and go to state 30
    selectid                       shift and go to state 33

state 109

    (48) logicexp -> logicterm OR logicexp .

    RPAREN          reduce using rule 48 (logicexp -> logicterm OR logicexp .)
    SEMICOLON       reduce using rule 48 (logicexp -> logicterm OR logicexp .)


state 110

    (50) logicterm -> logicfunction AND logicterm .

    OR              reduce using rule 50 (logicterm -> logicfunction AND logicterm .)
    RPAREN          reduce using rule 50 (logicterm -> logicfunction AND logicterm .)
    SEMICOLON       reduce using rule 50 (logicterm -> logicfunction AND logicterm .)


state 111

    (51) logicfunction -> idconst LESSTHAN idconst .

    AND             reduce using rule 51 (logicfunction -> idconst LESSTHAN idconst .)
    OR              reduce using rule 51 (logicfunction -> idconst LESSTHAN idconst .)
    RPAREN          reduce using rule 51 (logicfunction -> idconst LESSTHAN idconst .)
    SEMICOLON       reduce using rule 51 (logicfunction -> idconst LESSTHAN idconst .)


state 112

    (52) logicfunction -> idconst GREATERTHAN idconst .

    AND             reduce using rule 52 (logicfunction -> idconst GREATERTHAN idconst .)
    OR              reduce using rule 52 (logicfunction -> idconst GREATERTHAN idconst .)
    RPAREN          reduce using rule 52 (logicfunction -> idconst GREATERTHAN idconst .)
    SEMICOLON       reduce using rule 52 (logicfunction -> idconst GREATERTHAN idconst .)


state 113

    (53) logicfunction -> idconst EQUALS idconst .

    AND             reduce using rule 53 (logicfunction -> idconst EQUALS idconst .)
    OR              reduce using rule 53 (logicfunction -> idconst EQUALS idconst .)
    RPAREN          reduce using rule 53 (logicfunction -> idconst EQUALS idconst .)
    SEMICOLON       reduce using rule 53 (logicfunction -> idconst EQUALS idconst .)


state 114

    (38) arithexp -> arithterm PLUS arithexp .

    SEMICOLON       reduce using rule 38 (arithexp -> arithterm PLUS arithexp .)
    RPAREN          reduce using rule 38 (arithexp -> arithterm PLUS arithexp .)


state 115

    (39) arithexp -> arithterm MINUS arithexp .

    SEMICOLON       reduce using rule 39 (arithexp -> arithterm MINUS arithexp .)
    RPAREN          reduce using rule 39 (arithexp -> arithterm MINUS arithexp .)


state 116

    (41) arithterm -> arithfunction TIMES arithterm .

    PLUS            reduce using rule 41 (arithterm -> arithfunction TIMES arithterm .)
    MINUS           reduce using rule 41 (arithterm -> arithfunction TIMES arithterm .)
    SEMICOLON       reduce using rule 41 (arithterm -> arithfunction TIMES arithterm .)
    RPAREN          reduce using rule 41 (arithterm -> arithfunction TIMES arithterm .)


state 117

    (42) arithterm -> arithfunction DIVISION arithterm .

    PLUS            reduce using rule 42 (arithterm -> arithfunction DIVISION arithterm .)
    MINUS           reduce using rule 42 (arithterm -> arithfunction DIVISION arithterm .)
    SEMICOLON       reduce using rule 42 (arithterm -> arithfunction DIVISION arithterm .)
    RPAREN          reduce using rule 42 (arithterm -> arithfunction DIVISION arithterm .)


state 118

    (46) arithfunction -> LPAREN arithexp RPAREN .

    TIMES           reduce using rule 46 (arithfunction -> LPAREN arithexp RPAREN .)
    DIVISION        reduce using rule 46 (arithfunction -> LPAREN arithexp RPAREN .)
    PLUS            reduce using rule 46 (arithfunction -> LPAREN arithexp RPAREN .)
    MINUS           reduce using rule 46 (arithfunction -> LPAREN arithexp RPAREN .)
    SEMICOLON       reduce using rule 46 (arithfunction -> LPAREN arithexp RPAREN .)
    RPAREN          reduce using rule 46 (arithfunction -> LPAREN arithexp RPAREN .)


state 119

    (8) editvariables -> ID dimensions ASSIGN arithexp SEMICOLON .

    IF              reduce using rule 8 (editvariables -> ID dimensions ASSIGN arithexp SEMICOLON .)
    ID              reduce using rule 8 (editvariables -> ID dimensions ASSIGN arithexp SEMICOLON .)
    DO              reduce using rule 8 (editvariables -> ID dimensions ASSIGN arithexp SEMICOLON .)
    WHILE           reduce using rule 8 (editvariables -> ID dimensions ASSIGN arithexp SEMICOLON .)
    FOR             reduce using rule 8 (editvariables -> ID dimensions ASSIGN arithexp SEMICOLON .)
    CALL            reduce using rule 8 (editvariables -> ID dimensions ASSIGN arithexp SEMICOLON .)
    READ            reduce using rule 8 (editvariables -> ID dimensions ASSIGN arithexp SEMICOLON .)
    WRITE           reduce using rule 8 (editvariables -> ID dimensions ASSIGN arithexp SEMICOLON .)
    RBRACE          reduce using rule 8 (editvariables -> ID dimensions ASSIGN arithexp SEMICOLON .)


state 120

    (18) cyclical -> DO LBRACE severalstatutes RBRACE WHILE . LPAREN logicexp RPAREN

    LPAREN          shift and go to state 129


state 121

    (19) cyclical -> WHILE LPAREN logicexp RPAREN LBRACE . severalstatutes RBRACE
    (15) severalstatutes -> . statutes severalstatutes
    (16) severalstatutes -> . statutes
    (17) severalstatutes -> . empty
    (2) statutes -> . conditional
    (3) statutes -> . editvariables
    (4) statutes -> . cyclical
    (5) statutes -> . calling
    (6) statutes -> . readwrite
    (57) empty -> .
    (13) conditional -> . IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE
    (14) conditional -> . IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE ELSE LBRACE severalstatutes RBRACE
    (7) editvariables -> . ID ASSIGN arithexp SEMICOLON
    (8) editvariables -> . ID dimensions ASSIGN arithexp SEMICOLON
    (9) editvariables -> . selectid PLUSPLUS SEMICOLON
    (10) editvariables -> . selectid MINUSMINUS SEMICOLON
    (18) cyclical -> . DO LBRACE severalstatutes RBRACE WHILE LPAREN logicexp RPAREN
    (19) cyclical -> . WHILE LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE
    (20) cyclical -> . FOR LPAREN ID ASSIGN CONST SEMICOLON logicexp SEMICOLON arithexp RPAREN LBRACE severalstatutes RBRACE
    (30) calling -> . CALL ID LPAREN RPAREN SEMICOLON
    (31) readwrite -> . READ LPAREN idreadingloop RPAREN SEMICOLON
    (32) readwrite -> . WRITE LPAREN writecontent RPAREN SEMICOLON
    (11) selectid -> . ID
    (12) selectid -> . ID dimensions

    RBRACE          reduce using rule 57 (empty -> .)
    IF              shift and go to state 31
    ID              shift and go to state 32
    DO              shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    CALL            shift and go to state 37
    READ            shift and go to state 38
    WRITE           shift and go to state 39

    severalstatutes                shift and go to state 130
    statutes                       shift and go to state 24
    empty                          shift and go to state 25
    conditional                    shift and go to state 26
    editvariables                  shift and go to state 27
    cyclical                       shift and go to state 28
    calling                        shift and go to state 29
    readwrite                      shift and go to state 30
    selectid                       shift and go to state 33

state 122

    (20) cyclical -> FOR LPAREN ID ASSIGN CONST . SEMICOLON logicexp SEMICOLON arithexp RPAREN LBRACE severalstatutes RBRACE

    SEMICOLON       shift and go to state 131


state 123

    (30) calling -> CALL ID LPAREN RPAREN SEMICOLON .

    IF              reduce using rule 30 (calling -> CALL ID LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 30 (calling -> CALL ID LPAREN RPAREN SEMICOLON .)
    DO              reduce using rule 30 (calling -> CALL ID LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 30 (calling -> CALL ID LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 30 (calling -> CALL ID LPAREN RPAREN SEMICOLON .)
    CALL            reduce using rule 30 (calling -> CALL ID LPAREN RPAREN SEMICOLON .)
    READ            reduce using rule 30 (calling -> CALL ID LPAREN RPAREN SEMICOLON .)
    WRITE           reduce using rule 30 (calling -> CALL ID LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 30 (calling -> CALL ID LPAREN RPAREN SEMICOLON .)


state 124

    (31) readwrite -> READ LPAREN idreadingloop RPAREN SEMICOLON .

    IF              reduce using rule 31 (readwrite -> READ LPAREN idreadingloop RPAREN SEMICOLON .)
    ID              reduce using rule 31 (readwrite -> READ LPAREN idreadingloop RPAREN SEMICOLON .)
    DO              reduce using rule 31 (readwrite -> READ LPAREN idreadingloop RPAREN SEMICOLON .)
    WHILE           reduce using rule 31 (readwrite -> READ LPAREN idreadingloop RPAREN SEMICOLON .)
    FOR             reduce using rule 31 (readwrite -> READ LPAREN idreadingloop RPAREN SEMICOLON .)
    CALL            reduce using rule 31 (readwrite -> READ LPAREN idreadingloop RPAREN SEMICOLON .)
    READ            reduce using rule 31 (readwrite -> READ LPAREN idreadingloop RPAREN SEMICOLON .)
    WRITE           reduce using rule 31 (readwrite -> READ LPAREN idreadingloop RPAREN SEMICOLON .)
    RBRACE          reduce using rule 31 (readwrite -> READ LPAREN idreadingloop RPAREN SEMICOLON .)


state 125

    (33) idreadingloop -> ID COMA idreadingloop .

    RPAREN          reduce using rule 33 (idreadingloop -> ID COMA idreadingloop .)


state 126

    (32) readwrite -> WRITE LPAREN writecontent RPAREN SEMICOLON .

    IF              reduce using rule 32 (readwrite -> WRITE LPAREN writecontent RPAREN SEMICOLON .)
    ID              reduce using rule 32 (readwrite -> WRITE LPAREN writecontent RPAREN SEMICOLON .)
    DO              reduce using rule 32 (readwrite -> WRITE LPAREN writecontent RPAREN SEMICOLON .)
    WHILE           reduce using rule 32 (readwrite -> WRITE LPAREN writecontent RPAREN SEMICOLON .)
    FOR             reduce using rule 32 (readwrite -> WRITE LPAREN writecontent RPAREN SEMICOLON .)
    CALL            reduce using rule 32 (readwrite -> WRITE LPAREN writecontent RPAREN SEMICOLON .)
    READ            reduce using rule 32 (readwrite -> WRITE LPAREN writecontent RPAREN SEMICOLON .)
    WRITE           reduce using rule 32 (readwrite -> WRITE LPAREN writecontent RPAREN SEMICOLON .)
    RBRACE          reduce using rule 32 (readwrite -> WRITE LPAREN writecontent RPAREN SEMICOLON .)


state 127

    (28) methods -> METHOD ID LPAREN RPAREN LBRACE severalstatutes RBRACE methods .

    MAIN            reduce using rule 28 (methods -> METHOD ID LPAREN RPAREN LBRACE severalstatutes RBRACE methods .)


state 128

    (13) conditional -> IF LPAREN logicexp RPAREN LBRACE severalstatutes . RBRACE
    (14) conditional -> IF LPAREN logicexp RPAREN LBRACE severalstatutes . RBRACE ELSE LBRACE severalstatutes RBRACE

    RBRACE          shift and go to state 132


state 129

    (18) cyclical -> DO LBRACE severalstatutes RBRACE WHILE LPAREN . logicexp RPAREN
    (47) logicexp -> . logicterm
    (48) logicexp -> . logicterm OR logicexp
    (49) logicterm -> . logicfunction
    (50) logicterm -> . logicfunction AND logicterm
    (51) logicfunction -> . idconst LESSTHAN idconst
    (52) logicfunction -> . idconst GREATERTHAN idconst
    (53) logicfunction -> . idconst EQUALS idconst
    (54) logicfunction -> . LPAREN logicexp RPAREN
    (55) idconst -> . ID
    (56) idconst -> . CONST

    LPAREN          shift and go to state 57
    ID              shift and go to state 21
    CONST           shift and go to state 22

    logicexp                       shift and go to state 133
    logicterm                      shift and go to state 59
    logicfunction                  shift and go to state 60
    idconst                        shift and go to state 61

state 130

    (19) cyclical -> WHILE LPAREN logicexp RPAREN LBRACE severalstatutes . RBRACE

    RBRACE          shift and go to state 134


state 131

    (20) cyclical -> FOR LPAREN ID ASSIGN CONST SEMICOLON . logicexp SEMICOLON arithexp RPAREN LBRACE severalstatutes RBRACE
    (47) logicexp -> . logicterm
    (48) logicexp -> . logicterm OR logicexp
    (49) logicterm -> . logicfunction
    (50) logicterm -> . logicfunction AND logicterm
    (51) logicfunction -> . idconst LESSTHAN idconst
    (52) logicfunction -> . idconst GREATERTHAN idconst
    (53) logicfunction -> . idconst EQUALS idconst
    (54) logicfunction -> . LPAREN logicexp RPAREN
    (55) idconst -> . ID
    (56) idconst -> . CONST

    LPAREN          shift and go to state 57
    ID              shift and go to state 21
    CONST           shift and go to state 22

    logicexp                       shift and go to state 135
    logicterm                      shift and go to state 59
    logicfunction                  shift and go to state 60
    idconst                        shift and go to state 61

state 132

    (13) conditional -> IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE .
    (14) conditional -> IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE . ELSE LBRACE severalstatutes RBRACE

    IF              reduce using rule 13 (conditional -> IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE .)
    ID              reduce using rule 13 (conditional -> IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE .)
    DO              reduce using rule 13 (conditional -> IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE .)
    WHILE           reduce using rule 13 (conditional -> IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE .)
    FOR             reduce using rule 13 (conditional -> IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE .)
    CALL            reduce using rule 13 (conditional -> IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE .)
    READ            reduce using rule 13 (conditional -> IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE .)
    WRITE           reduce using rule 13 (conditional -> IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE .)
    RBRACE          reduce using rule 13 (conditional -> IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE .)
    ELSE            shift and go to state 136


state 133

    (18) cyclical -> DO LBRACE severalstatutes RBRACE WHILE LPAREN logicexp . RPAREN

    RPAREN          shift and go to state 137


state 134

    (19) cyclical -> WHILE LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE .

    IF              reduce using rule 19 (cyclical -> WHILE LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE .)
    ID              reduce using rule 19 (cyclical -> WHILE LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE .)
    DO              reduce using rule 19 (cyclical -> WHILE LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE .)
    WHILE           reduce using rule 19 (cyclical -> WHILE LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE .)
    FOR             reduce using rule 19 (cyclical -> WHILE LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE .)
    CALL            reduce using rule 19 (cyclical -> WHILE LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE .)
    READ            reduce using rule 19 (cyclical -> WHILE LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE .)
    WRITE           reduce using rule 19 (cyclical -> WHILE LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE .)
    RBRACE          reduce using rule 19 (cyclical -> WHILE LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE .)


state 135

    (20) cyclical -> FOR LPAREN ID ASSIGN CONST SEMICOLON logicexp . SEMICOLON arithexp RPAREN LBRACE severalstatutes RBRACE

    SEMICOLON       shift and go to state 138


state 136

    (14) conditional -> IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE ELSE . LBRACE severalstatutes RBRACE

    LBRACE          shift and go to state 139


state 137

    (18) cyclical -> DO LBRACE severalstatutes RBRACE WHILE LPAREN logicexp RPAREN .

    IF              reduce using rule 18 (cyclical -> DO LBRACE severalstatutes RBRACE WHILE LPAREN logicexp RPAREN .)
    ID              reduce using rule 18 (cyclical -> DO LBRACE severalstatutes RBRACE WHILE LPAREN logicexp RPAREN .)
    DO              reduce using rule 18 (cyclical -> DO LBRACE severalstatutes RBRACE WHILE LPAREN logicexp RPAREN .)
    WHILE           reduce using rule 18 (cyclical -> DO LBRACE severalstatutes RBRACE WHILE LPAREN logicexp RPAREN .)
    FOR             reduce using rule 18 (cyclical -> DO LBRACE severalstatutes RBRACE WHILE LPAREN logicexp RPAREN .)
    CALL            reduce using rule 18 (cyclical -> DO LBRACE severalstatutes RBRACE WHILE LPAREN logicexp RPAREN .)
    READ            reduce using rule 18 (cyclical -> DO LBRACE severalstatutes RBRACE WHILE LPAREN logicexp RPAREN .)
    WRITE           reduce using rule 18 (cyclical -> DO LBRACE severalstatutes RBRACE WHILE LPAREN logicexp RPAREN .)
    RBRACE          reduce using rule 18 (cyclical -> DO LBRACE severalstatutes RBRACE WHILE LPAREN logicexp RPAREN .)


state 138

    (20) cyclical -> FOR LPAREN ID ASSIGN CONST SEMICOLON logicexp SEMICOLON . arithexp RPAREN LBRACE severalstatutes RBRACE
    (37) arithexp -> . arithterm
    (38) arithexp -> . arithterm PLUS arithexp
    (39) arithexp -> . arithterm MINUS arithexp
    (40) arithterm -> . arithfunction
    (41) arithterm -> . arithfunction TIMES arithterm
    (42) arithterm -> . arithfunction DIVISION arithterm
    (43) arithfunction -> . idconst
    (44) arithfunction -> . ID PLUSPLUS
    (45) arithfunction -> . ID MINUSMINUS
    (46) arithfunction -> . LPAREN arithexp RPAREN
    (55) idconst -> . ID
    (56) idconst -> . CONST

    ID              shift and go to state 62
    LPAREN          shift and go to state 67
    CONST           shift and go to state 22

    arithexp                       shift and go to state 140
    arithterm                      shift and go to state 64
    arithfunction                  shift and go to state 65
    idconst                        shift and go to state 66

state 139

    (14) conditional -> IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE ELSE LBRACE . severalstatutes RBRACE
    (15) severalstatutes -> . statutes severalstatutes
    (16) severalstatutes -> . statutes
    (17) severalstatutes -> . empty
    (2) statutes -> . conditional
    (3) statutes -> . editvariables
    (4) statutes -> . cyclical
    (5) statutes -> . calling
    (6) statutes -> . readwrite
    (57) empty -> .
    (13) conditional -> . IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE
    (14) conditional -> . IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE ELSE LBRACE severalstatutes RBRACE
    (7) editvariables -> . ID ASSIGN arithexp SEMICOLON
    (8) editvariables -> . ID dimensions ASSIGN arithexp SEMICOLON
    (9) editvariables -> . selectid PLUSPLUS SEMICOLON
    (10) editvariables -> . selectid MINUSMINUS SEMICOLON
    (18) cyclical -> . DO LBRACE severalstatutes RBRACE WHILE LPAREN logicexp RPAREN
    (19) cyclical -> . WHILE LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE
    (20) cyclical -> . FOR LPAREN ID ASSIGN CONST SEMICOLON logicexp SEMICOLON arithexp RPAREN LBRACE severalstatutes RBRACE
    (30) calling -> . CALL ID LPAREN RPAREN SEMICOLON
    (31) readwrite -> . READ LPAREN idreadingloop RPAREN SEMICOLON
    (32) readwrite -> . WRITE LPAREN writecontent RPAREN SEMICOLON
    (11) selectid -> . ID
    (12) selectid -> . ID dimensions

    RBRACE          reduce using rule 57 (empty -> .)
    IF              shift and go to state 31
    ID              shift and go to state 32
    DO              shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    CALL            shift and go to state 37
    READ            shift and go to state 38
    WRITE           shift and go to state 39

    severalstatutes                shift and go to state 141
    statutes                       shift and go to state 24
    empty                          shift and go to state 25
    conditional                    shift and go to state 26
    editvariables                  shift and go to state 27
    cyclical                       shift and go to state 28
    calling                        shift and go to state 29
    readwrite                      shift and go to state 30
    selectid                       shift and go to state 33

state 140

    (20) cyclical -> FOR LPAREN ID ASSIGN CONST SEMICOLON logicexp SEMICOLON arithexp . RPAREN LBRACE severalstatutes RBRACE

    RPAREN          shift and go to state 142


state 141

    (14) conditional -> IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE ELSE LBRACE severalstatutes . RBRACE

    RBRACE          shift and go to state 143


state 142

    (20) cyclical -> FOR LPAREN ID ASSIGN CONST SEMICOLON logicexp SEMICOLON arithexp RPAREN . LBRACE severalstatutes RBRACE

    LBRACE          shift and go to state 144


state 143

    (14) conditional -> IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE ELSE LBRACE severalstatutes RBRACE .

    IF              reduce using rule 14 (conditional -> IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE ELSE LBRACE severalstatutes RBRACE .)
    ID              reduce using rule 14 (conditional -> IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE ELSE LBRACE severalstatutes RBRACE .)
    DO              reduce using rule 14 (conditional -> IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE ELSE LBRACE severalstatutes RBRACE .)
    WHILE           reduce using rule 14 (conditional -> IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE ELSE LBRACE severalstatutes RBRACE .)
    FOR             reduce using rule 14 (conditional -> IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE ELSE LBRACE severalstatutes RBRACE .)
    CALL            reduce using rule 14 (conditional -> IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE ELSE LBRACE severalstatutes RBRACE .)
    READ            reduce using rule 14 (conditional -> IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE ELSE LBRACE severalstatutes RBRACE .)
    WRITE           reduce using rule 14 (conditional -> IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE ELSE LBRACE severalstatutes RBRACE .)
    RBRACE          reduce using rule 14 (conditional -> IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE ELSE LBRACE severalstatutes RBRACE .)


state 144

    (20) cyclical -> FOR LPAREN ID ASSIGN CONST SEMICOLON logicexp SEMICOLON arithexp RPAREN LBRACE . severalstatutes RBRACE
    (15) severalstatutes -> . statutes severalstatutes
    (16) severalstatutes -> . statutes
    (17) severalstatutes -> . empty
    (2) statutes -> . conditional
    (3) statutes -> . editvariables
    (4) statutes -> . cyclical
    (5) statutes -> . calling
    (6) statutes -> . readwrite
    (57) empty -> .
    (13) conditional -> . IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE
    (14) conditional -> . IF LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE ELSE LBRACE severalstatutes RBRACE
    (7) editvariables -> . ID ASSIGN arithexp SEMICOLON
    (8) editvariables -> . ID dimensions ASSIGN arithexp SEMICOLON
    (9) editvariables -> . selectid PLUSPLUS SEMICOLON
    (10) editvariables -> . selectid MINUSMINUS SEMICOLON
    (18) cyclical -> . DO LBRACE severalstatutes RBRACE WHILE LPAREN logicexp RPAREN
    (19) cyclical -> . WHILE LPAREN logicexp RPAREN LBRACE severalstatutes RBRACE
    (20) cyclical -> . FOR LPAREN ID ASSIGN CONST SEMICOLON logicexp SEMICOLON arithexp RPAREN LBRACE severalstatutes RBRACE
    (30) calling -> . CALL ID LPAREN RPAREN SEMICOLON
    (31) readwrite -> . READ LPAREN idreadingloop RPAREN SEMICOLON
    (32) readwrite -> . WRITE LPAREN writecontent RPAREN SEMICOLON
    (11) selectid -> . ID
    (12) selectid -> . ID dimensions

    RBRACE          reduce using rule 57 (empty -> .)
    IF              shift and go to state 31
    ID              shift and go to state 32
    DO              shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    CALL            shift and go to state 37
    READ            shift and go to state 38
    WRITE           shift and go to state 39

    severalstatutes                shift and go to state 145
    statutes                       shift and go to state 24
    empty                          shift and go to state 25
    conditional                    shift and go to state 26
    editvariables                  shift and go to state 27
    cyclical                       shift and go to state 28
    calling                        shift and go to state 29
    readwrite                      shift and go to state 30
    selectid                       shift and go to state 33

state 145

    (20) cyclical -> FOR LPAREN ID ASSIGN CONST SEMICOLON logicexp SEMICOLON arithexp RPAREN LBRACE severalstatutes . RBRACE

    RBRACE          shift and go to state 146


state 146

    (20) cyclical -> FOR LPAREN ID ASSIGN CONST SEMICOLON logicexp SEMICOLON arithexp RPAREN LBRACE severalstatutes RBRACE .

    IF              reduce using rule 20 (cyclical -> FOR LPAREN ID ASSIGN CONST SEMICOLON logicexp SEMICOLON arithexp RPAREN LBRACE severalstatutes RBRACE .)
    ID              reduce using rule 20 (cyclical -> FOR LPAREN ID ASSIGN CONST SEMICOLON logicexp SEMICOLON arithexp RPAREN LBRACE severalstatutes RBRACE .)
    DO              reduce using rule 20 (cyclical -> FOR LPAREN ID ASSIGN CONST SEMICOLON logicexp SEMICOLON arithexp RPAREN LBRACE severalstatutes RBRACE .)
    WHILE           reduce using rule 20 (cyclical -> FOR LPAREN ID ASSIGN CONST SEMICOLON logicexp SEMICOLON arithexp RPAREN LBRACE severalstatutes RBRACE .)
    FOR             reduce using rule 20 (cyclical -> FOR LPAREN ID ASSIGN CONST SEMICOLON logicexp SEMICOLON arithexp RPAREN LBRACE severalstatutes RBRACE .)
    CALL            reduce using rule 20 (cyclical -> FOR LPAREN ID ASSIGN CONST SEMICOLON logicexp SEMICOLON arithexp RPAREN LBRACE severalstatutes RBRACE .)
    READ            reduce using rule 20 (cyclical -> FOR LPAREN ID ASSIGN CONST SEMICOLON logicexp SEMICOLON arithexp RPAREN LBRACE severalstatutes RBRACE .)
    WRITE           reduce using rule 20 (cyclical -> FOR LPAREN ID ASSIGN CONST SEMICOLON logicexp SEMICOLON arithexp RPAREN LBRACE severalstatutes RBRACE .)
    RBRACE          reduce using rule 20 (cyclical -> FOR LPAREN ID ASSIGN CONST SEMICOLON logicexp SEMICOLON arithexp RPAREN LBRACE severalstatutes RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 24 resolved using rule (severalstatutes -> statutes)
WARNING: rejected rule (empty -> <empty>) in state 24
